#!/bin/bash
set -euo pipefail

# ini_get and ini_set will wrap this
# based on old script expanded a bit with ChatGPT

LOCK_FD=200
LOCK_RETRIES=10
LOCK_WAIT=0.1

INI_FILE=""
SECTION=""
KEY=""
VALUE=""
ACTION=""

# Print usage to STDERR
usage() {
    cat >&2 << EOF
Usage: $0 [-r|-w|-d|--list-sections|--list-keys|--show-all] -s SECTION [-k KEY] [-v VALUE] file.ini

Exit Codes (Read):
  0 - Success (found key or section)
  1 - Section missing
  2 - File missing/unreadable
  3 - Format invalid
  4 - Key missing in section
 101 - Bad usage

Exit Codes (Write/Delete):
  0 - Success
  1 - Failed to perform action
 101 - Bad usage
EOF
}

log() {
    echo "[ERROR] $*" >&2
}

# Lightweight INI format validation: at least one section [x] and key=value
validate_ini() {
    if [[ ! -r "$INI_FILE" ]]; then return 2; fi
    if ! grep -qE '^\[.*\]' "$INI_FILE"; then return 3; fi
    if ! grep -qE '^[^#;].*=.*$' "$INI_FILE"; then return 3; fi
    return 0
}

read_ini_value() {
    [[ ! -f "$INI_FILE" || ! -r "$INI_FILE" ]] && return 2
    validate_ini || return $?

    local found_section=0
    local found_key=1

    while IFS= read -r line; do
        [[ "$line" =~ ^[[:space:]]*\[.*\][[:space:]]*$ ]] && {
            if [[ "$line" == "[$SECTION]" ]]; then
                found_section=1
            else
                [[ $found_section -eq 1 ]] && break
            fi
        }

        [[ $found_section -eq 1 && "$line" =~ ^[[:space:]]*([^#;].*?)=(.*) ]] && {
            if [[ "${BASH_REMATCH[1]// /}" == "$KEY" ]]; then
                echo "${BASH_REMATCH[2]}" && return 0
            fi
        }
    done < "$INI_FILE"

    [[ $found_section -eq 0 ]] && return 1
    [[ -n "$KEY" ]] && return 4
    return 0
}

write_ini_value() {
    [[ -z "$SECTION" || -z "$KEY" ]] && return 101
    validate_ini || true

    local tmp_file
    tmp_file=$(mktemp)
    local in_section=0
    local key_written=0
    local section_written=0

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^[[:space:]]*\[.*\][[:space:]]*$ ]]; then
            if [[ $in_section -eq 1 && $key_written -eq 0 ]]; then
                echo "$KEY=$VALUE" >> "$tmp_file"
                key_written=1
            fi

            if [[ "$line" == "[$SECTION]" ]]; then
                in_section=1
                section_written=1
            else
                in_section=0
            fi

            echo "$line" >> "$tmp_file"
            continue
        fi

        if [[ $in_section -eq 1 && "$line" =~ ^[[:space:]]*([^#;].*?)=.* ]]; then
            if [[ "${BASH_REMATCH[1]// /}" == "$KEY" ]]; then
                echo "$KEY=$VALUE" >> "$tmp_file"
                key_written=1
                continue
            fi
        fi

        echo "$line" >> "$tmp_file"
    done < "$INI_FILE"

    # If section not found, add section + key=value at end
    if [[ $section_written -eq 0 ]]; then
        echo -e "\n[$SECTION]" >> "$tmp_file"
        echo "$KEY=$VALUE" >> "$tmp_file"
        key_written=1
    elif [[ $key_written -eq 0 ]]; then
        echo "$KEY=$VALUE" >> "$tmp_file"
    fi

    mv "$tmp_file" "$INI_FILE"
    return 0
}


delete_ini_key() {
    [[ -z "$SECTION" || -z "$KEY" ]] && return 101
    validate_ini || return $?

    local tmp_file
    tmp_file=$(mktemp)

    awk -v section="$SECTION" -v key="$KEY" '
    BEGIN {in_section=0}
    /^\[.*\]/ {
        in_section = ($0 == "[" section "]")
        print; next
    }
    {
        if (in_section && $0 ~ "^[ \t]*" key "[ \t]*=") next
        print
    }
    ' "$INI_FILE" > "$tmp_file" && mv "$tmp_file" "$INI_FILE" || return 1

    return 0
}

list_sections() {
    grep -o '^\[.*\]' "$INI_FILE" | sed 's/^\[\(.*\)\]$/\1/'
}

list_keys() {
    local found=0
    local inside=0
    while IFS= read -r line; do
        [[ "$line" =~ ^\[.*\]$ ]] && {
            inside=0
            [[ "$line" == "[$SECTION]" ]] && inside=1 && found=1
            continue
        }
        [[ $inside -eq 1 && "$line" =~ ^([^#;].*?)= ]] && echo "${BASH_REMATCH[1]}"
    done < "$INI_FILE"
    [[ $found -eq 0 ]] && return 1
    return 0
}

show_all() {
    cat "$INI_FILE"
}

main() {
    [[ $# -lt 1 ]] && usage && exit 101

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -r|--read) ACTION="read" ;;
            -w|--write) ACTION="write" ;;
            -d|--delete) ACTION="delete" ;;
            --list-sections) ACTION="list_sections" ;;
            --list-keys) ACTION="list_keys" ;;
            --show-all) ACTION="show_all" ;;
            -s) SECTION="$2"; shift ;;
            -k) KEY="$2"; shift ;;
            -v) VALUE="$2"; shift ;;
            -h|--help) usage; exit 0 ;;
            -*)
                log "Unknown option: $1"
                usage; exit 101 ;;
            *) INI_FILE="$1" ;;
        esac
        shift
    done

    [[ -z "$INI_FILE" ]] && log "INI file required" && usage && exit 101

    LOCK_FILE="/tmp/ini_manager.$(basename "$INI_FILE").lock"
    exec {LOCK_FD}>"$LOCK_FILE" || exit 1
    for ((i = 1; i <= LOCK_RETRIES; i++)); do
        flock -xn "$LOCK_FD" && break
        [[ $i -eq LOCK_RETRIES ]] && log "Could not acquire lock" && exit 1
        sleep "$LOCK_WAIT"
    done

    case "$ACTION" in
        read)
            if [[ -z "$SECTION" ]]; then usage; exit 101; fi
            read_ini_value && exit $? || exit $?
            ;;
        write)
            write_ini_value && exit 0 || exit 1
            ;;
        delete)
            delete_ini_key && exit 0 || exit 1
            ;;
        list_sections)
            list_sections && exit 0 || exit 1
            ;;
        list_keys)
            [[ -z "$SECTION" ]] && usage && exit 101
            list_keys && exit 0 || exit 1
            ;;
        show_all)
            show_all && exit 0 || exit 1
            ;;
        *) usage; exit 101 ;;
    esac
}

main "$@"
